:PROPERTIES:
:ID:       20231024T112734.315362
:END:
#+title: Fortran Preprocessor High-Level Requirements
#+author: INCITS/Fortran JoR
#+date: [2023-10-24 Tue 11:27]
#+options: toc:nil
#+startup: showall
#+options: toc:t H:5 num:4
#+latex_header: \usepackage{titlesec}
# #+latex_header: \usepackage{parskip}
#+latex_header: \usepackage{hyperref}
#+latex_header: \usepackage{textgreek}
#+latex_header: \usepackage{listings}
#+latex_header: \hypersetup{linktoc = all, colorlinks = true, urlcolor = blue, citecolor = blue, linkcolor = blue}
#+latex_header: \titlespacing{\subsection}{0pt}{*4}{*1.5}
#+latex_header: \titlespacing{\subsubsection}{0pt}{*4}{*1.5}
# #+latex_header: \parindent=0pt
#+latex_header: \setcounter{secnumdepth}{5}
#+latex_header: \setcounter{tocdepth}{4}


#  LocalWords:  Clu Lio Ble Kli Fortranized Jor VARNAME


* Introduction
INCITS/Fortran has talked several times in Plenary, and the JoR subgroup has met several times, to lay down formal requirements for the proposed Fortran preprocessor (FPP) for Fortran 202y (presumably 2028).

This paper lists the requirements and how JoR came to them.

The first section, ``Guiding Principles'', describes the value system we use to evaluate which requirements are most import (or unimportant) for the Fortran preprocessor.

The second section, ``On Fortran source form'', describes the peculiarities of Fortran source, C source, C preprocessor (CPP) directives, and which conventions we will follow for FPP.

The third section describes phases of the translation process that lead up to preprocessing and subesequent processing by ``the processor'' itself.

The last section details individual requirements.


** Citing standards and /de facto/ standards
For brevity we write references to the Fortran 2023 standard [[cite:&iso-iec-jtc1-2023-prog-lang-fortran]] as follows:
    + =[F2023=,
    + the section marker =§= and the clause number, then one of
        - =R= followed by a rule number, or
        - =C= followed by a constraint number, or
        - =¶= followed by the paragraph number,  and (optionally) a bullet symbol =·= and the bullet number or letter
    + (optionally) the section title for redundant context,
    + a closing square bracket =]=.

For example, =[F2023§13.2.1R1301 FORMAT statement]= refers to subclause 13.2.1 (=`FORMAT statement=') of the Fortran 2023 standard, rule 1301.

We follow a similar convention for the 2018 C programming language standard [[cite:&iso-iec-2018-prog-lang-c]], starting with =[C2018=. So, =[C2018§5.1.1.2¶1·2 Translation phases]= refers to subclause 5.1.1.2 (``Translation phases'') of the C 2018 standard, paragraph 1, second bullet point.

Likewise, for the GNUCC ``The C Preprocessor'' manual [[cite:&stallman-2024-c-preprocessor]], starting with =[G14=. So, =[G14§3.3¶2 Macro Arguments]= refers to paragraph 2 of section 3.3 (``Macro Arguments'') of version 13 of the GNU CPP reference.

And for LLVM Flang's ``Fortran Preprocessing'' [[https://github.com/llvm/llvm-project/blob/main/flang/docs/Preprocessing.md][Preprocessing.md]] [[cite:&llvm-2024-flang-fortran-preproc]], starting with =Flpp=, and counting section numbers by level 2 headings. So, =[Flpp§2·1 Invoked macro names can straddle]= refers to the first bullet in the second section (``Behavior that is not consistent over all extant compilers but which probably should be uncontroversial'').


* Guiding principles
We start by deciding what is important and what is less important (or unimportant) up front for FPP. Guiding principles provide a /value system/ for evaluating technical alternatives.

** Promote portability
Many programs depend on some preprocessing capability. Most of these rely on a preprocessor that is, or behave much like, the C preprocessor (CPP) [[cite:&iso-iec-1999-prog-lang-c]]. Many of these Fortran preprocessors support different versions of the C preprocessor specification, or exhibit different behavior from each other.

The main goal of this project is to promote the portability of programs that rely on CPP-like behavior by standardizing the semantics of a Fortran preprocessor and making it a mandatory feature of standards-complying processors.


** Be ``Fortran-aware''
Fortran is not C, and has certain issues in its source form that require special attention [[cite:&klimowicz-2024-fortran-awareness]] that aren't needed in CPP.
- Fortran has two distinct source forms: fixed-form and free-form. FPP should support both.
- Some Fortran tokens and C tokens have different meaning: =//= means concatenation in Fortran, but introduces comments in C; =!= is the `not' operator in C, but introduces comments in Fortran.
- There are source statements in Fortran where we don't necessarily want macro expansion, such as in the =IMPLICIT= /implicit-spec-list/ ([[cite:&iso-iec-jtc1-2023-prog-lang-fortran]] §8.7) and in the =FORMAT= /format-items/ (§13.3).


** Support a meaningful subset of CPP
Deliver a viable product. Support the subset of CPP that used by existing Fortran projects. Add the minimum features necessary to support current and near-future use.

Full compatibility with CPP [[cite:&iso-iec-2018-prog-lang-c]] §6.10 is not required.

When Fortran conventions (such as case-insensitivity) conflict with CPP conventions, lean towards CPP.

Accommodate existing use of CPP-like Fortran preprocessor when there is consensus among the existing processor implementations.


* High-level requirements
At a certain altitude, FPP will be an unholy marriage of  some of the syntax and semantics from the C standard, and some of the syntax an semantics from the Fortran standard.

** CPP conventions we should follow
As existing projects use CPP, or a variant of it, FPP should exhibit the following behaviors. [[cite:&iso-iec-2018-prog-lang-c]].
*** Whitespace is significant in delimiting tokens
Rationale: In CPP, the space character (hex 0x20), the tab character, and new-line delimit tokens.

*** Case-sensitivity in directive names and token names
Rationale: Macro variable names and directive commands are case-sensitive in CPP. The identifiers =i= and =I= are distinct. (In Fortran, identifiers are not case-sensitive:  =i= and =I= are the same identifier.) We are aware of at least one large application that relies on preprocessor identifiers being distinct that differ only in case.

*** Line continuation with backslash new-line in directives
The C convention is that the sequence of a backslash character (=\=) immediately followed by a new-line character is deleted.

*** C expressions in =#if= and =#elif= directives
C has no built-in Boolean type, so the expressions in conditional directives are C integer expressions. An integer zero value represents ``false'', and any non-zero value represents ``true''. (Fortran supports =LOGICAL= values as a separate type.)
*** =/*= ... =*/= comments in directives
CPP recognizes C-style comments. (Fortran introduces comments with exclamation marks (=!=).)
*** =&= and =&&= operators in directives
CPP has operators =&= and =&&= on integer expressions. (Fortran free-form lines use =&= at the end of a line to signal continuation.
*** C tokens allowed in directives
Recognize C tokens in macro definition and conditional directives.



** CPP conventions we should /not/ follow
FPP should not adopt the following behaviors from CPP.
*** =//= introducing comments in directives
Rationale: The =//= operator is the Fortran character concatenation operator, and is a valid token in FPP.


** Fortran conventions we should follow
*** Macro expansion in fixed-form Fortran
Rationale: Fortran projects today still exist in the obsolescent fixed-form [[cite:&iso-iec-jtc1-2023-prog-lang-fortran]]. Roughly half the projects and lines of code we have collected so far, in fact contain fixed-form Fortran [[cite:&klimowicz-2024-preproc-direct-exist-fortran-program]].

FPP must behave reasonably on this large body of code, but also must bend to conventions used by CPP.


** Fortran conventions we should /not/ follow
*** In fixed-form Fortran, blanks are not significant for determining token boundaries
Rationale: CPP  treats blanks and comments as significant for determining token boundaries (they are significant up until translation phase 7 [C2018§5.1.1.2¶8·7]). We follow the CPP convention for tokenizing identifiers. Existing program surely rely on this, but we haven't analyzed this yet in the corpus of existing programs.

*** =!= comments in directives
Rationale: =!= introduces a comment in Fortran. Unfortunately, this is also the C `not' operator. To allow conditions with the C =!= not operator (such as below), FPP must treat =!= as the C `not' operator.
#+begin_src c
! defined(MY_FAVORITE_ID)
#+end_src


** Features to decide or revisit
*** Fortran operators in directives
For FPP directives, we should use C-style expressions, not Fortran expressions. Operators such as ===, =/==, =.AND.=, =.OR.=, =.NOT=., =**= should not appear in =#if= and =#elif= directives. These operators, of course, can appear in the replacement text of =#define= directives.

*** Comments become spaces in Fortran source
In C, a comment is replaced with a single space before it executes preprocessor directives. Since Fortran has never had any kind of formal =pragma= line in the language, programmers embed Fortran compiler directives (e.g., regarding vectorizing optimizations, OpenMP and OpenACC parallelism, and legacy extensions) in comments. FPP must in some way preserve these comment-based directives for the processor.


* Translation phases
The C standard [[cite:&iso-iec-2018-prog-lang-c]] defines eight translation phases. These phases each perform a well-defined set of operations on the C source code and intermediate representations.

These phases describe how C compilers should behave. They do not describe how C compilers should be written.

We will do the same for Fortran. For FPP, though, we are only concerned with phases 0 through 5. The rest of the Fortran standard defines the responsibilities of ``The Processor''.


** Phase 1: Remove continuations
For follow the column-6 conventions to produce a sequence of logical lines.

For free-form source, follow the =&= conventions to produce a sequence of logical lines.



** Phase 2: Translate comment directives
For fixed and free-form source, translate comment-based directives (such as =!dir$=, =!omp$=, =!acc$=) into =#pragma= directives.

Which comment-directives are translated to =#pragma= directives is processor-dependent.


** Phase 3: Remove comments
All remaining comments are replaced with a single space.


** Phase 4: Tokenize the source into preprocessing tokens
The output from Phase 3 is converted to preprocessor tokens according to the rules defined in ``On Fortran source form'' above.


** Phase 5: Execute preprocessor directives
Preprocessing directives in the output from Phase 4 are executed. Macros are expanded in directives and Fortran source.


** Phase 6: Convert preprocessing tokens to tokens
The output from Phase 5 is converted to tokens suitable for syntactic analysis.


** Phase 7: ``The Processor''

*** Analyze syntax
Analyze the output from Phase 6 for syntactic correctness. Construct any necessary intermediate representation for semantic analysis.

*** Analyze semantic correctness
Find and report static semantic errors in the Fortran program. Check for Fortran constraint violations.

*** Generate code
Translate the output from Phase 7 to runnable code.


* Detailed requirements
:PROPERTIES:
:COLUMNS:  %30reqid(ID) %6status(Status) %10TAGS(Export) %30csource(Sources) %60ITEM(Description)
:END:

We list the detailed requirements for the Fortran 202y preprocessor.

Each requirement is a heading of the form ``One-line description''

Item properties for these headings contain
    - A requirement unique identifier in square brackets =[= =]=.
    - Current status (TBD, JoR yes, JoR no, WG 5 yes, WG 5 no, etc.).
    - Normative references (such as the C standard).
    - Where the requirement came from in normative references (such as the C standard), J3 Fortran discussions and posts.

The requirements came from the following sources.
- cpp :: The C standard [[cite:&iso-iec-2018-prog-lang-c]].
- facpp :: The C standard, but made Fortran-aware.
- ble1 :: JoR Email threads from Rich Bleikamp re: tutorial [2022-08-08 Mon 21:34].
- che1 :: Email from Daniel Chen to JoR [2022-07-29 11:08].
- clu1 :: Email from Tom Clune [2022-08-01 Mon 10:48].
- gak :: Gary Klimowicz as he wrote these specifications.
- jor1 :: JoR meeting on preprocessors [2022-08-22 Mon 10:00].
- jor2 :: JoR meeting on preprocessors [2022-09-20 Tue 13:00].
- jor3 :: JoR meeting on preprocessors [2023-11-07 Tue 12:00].
- jor4 :: JoR meeting on preprocessors [2022-12-06 Tue 12:00].
- lio1 :: Email from Steve Lionel [2022-08-01 Mon 13:52].
- lio2 :: JoR discussion forum [[https://j3-fortran.org/forum/viewtopic.php?p=561]].
- lio3 :: JoR discussion forum [[https://j3-fortran.org/forum/viewtopic.php?p=562]].


** Phase 1 Remove continuations

*** Directives

**** Directive lines are not bound by fixed-form conventions

***** Column 6 in a directive line does not mark a continuation
:PROPERTIES:
:reqid: [dir-column-6-not-cont]
:status: TBD
:source: [Flpp§]
:references: [C§5.1.1.2¶1·2 Translation phases]
:END:

**** Recognize C-style =\new-line= line continuations in directives
:PROPERTIES:
:reqid: [c-backslash-dir]
:status: TBD
:source: ]
:references: [C§5.1.1.2¶1·2 Translation phases], [Flpp§1·3 Fixed form right margin clipping
:END:

In a directive line fixed-form and free-from source code, delete a backslash =\= immediately followed by a new-line character. The following line continues the directive line.

From The C standard:
#+begin_quote
Each instance of a backslash character (\) immediately followed by a new-line character is deleted, splicing physical source lines to form logical source lines. Only the last backslash on any physical source line shall be eligible for being part of such a splice. A source file that is not empty shall end in a new-line character, which shall not be immediately preceded by a backslash character before any such splicing takes place.
#+end_quote

**** Comment lines in definitions with continuation lines
:PROPERTIES:
:reqid: [comment-definition-cont]
:status: TBD
:source: [Flpp§], [C§6.10 Preprocessing directives]
:END:


*** Fixed form Fortran
**** Remove Fortran line 6 continuation in fixed-form Fortran text
:PROPERTIES:
:reqid: [fortran-cont-fixed-6]
:status: TBD
:source: che1
:END:

In fixed-form input, a character in column 6 that is not blank or the digit zero continues the line with the previous line, even if the previous line is a directive line, or the continuation of a directive line.



**** Identifier tokens are not broken by fixed-form line continuations
:PROPERTIES:
:reqid: [identifiers-span-continuations]
:status: TBD
:source: jor4, [F2023§6.2.2C601]
:tests: [Flpp pp005.F KWM split across continuation, implicit padding], [Flpp pp006.F ditto, but with intervening *comment line]
:END:

In fixed-form, there are only 66 characters available for statement text (columns 7-72). The maximum length of an identifier is 63 characters. It is not practical to have identifiers end at a fixed-form line boundary at column 72.


*** Free form Fortran
**** Remove Fortran =&= line continuation in free-form Fortran text
:PROPERTIES:
:reqid: [fortran-cont-free-amp]
:status: TBD
:source: che1, [C§6.10 Preprocessing directives]
:END:

In free-form input, an =&= character as the last character on a directive line indicates the directive continues on the next line. The handling of the continuation is as described in [F2023§6.3.2.4].


**** Remove Fortran =&= line continuation followed by =!= comment in free-form Fortran text
:PROPERTIES:
:reqid: [fortran-cont-free-amp-comment]
:status: TBD
:source:   che1, [C§6.10 Preprocessing directives], [F2023§6.3.2.3 Free form commentary], [F2023§6.3.2.4 Free form statement continuation]
:END:

In free-form input, an =&= character as the last character on a directive line indicates the directive continues on the next line. The handling of the continuation is as described in [F2023§6.3.2.4].
**** Remove leading spaces before =&= in Fortran line continuation in free form
:PROPERTIES:
:REQID:    [fortran-cont-free-rm-lead-amp]
:status: TBD
:source: che1, [C§6.10 Preprocessing directives]
:END:

In free-form input, an =&= character as the last character on a directive line indicates the directive continues on the next  line. When the first non-blank character on the next line is also an =&=, the characters between the ampersands are deleted.




*** Questions
**** How do we handle comments embedded between continuation lines?

****

**** Are any comment-based directives sandwiched between continuation lines?


** Phase 2 Translate comment directives

*** Convert Fortran line comments to =#pragma= directives in fixed-form


*** Questions
**** What projects depend on keyword macro expansion in column 1?

** Phase 3 Remove comments
*** Strip C-style =/* ... */= comments in directive lines
:PROPERTIES:
:reqid: [remove-c-comment-dir]
:status: TBD
:source: [Flpp§], [C§6.10¶5 Constraints], [C§6.10.1¶6f172 Semantics]
:END:

*** Strip fixed-form comments
:reqid: [remove-fixed-form-col-1-comment]
:status: TBD
:source: [Flpp§], [C§6.10¶5 Constraints], [C§6.10.1¶6f172 Semantics]
:END:

*** Strip free-form comments
:reqid: [remove-free-form-bang-comment]
:status: TBD
:source: [Flpp§], [C§6.10¶5 Constraints], [C§6.10.1¶6f172 Semantics]
:END:

*** Questions
**** What projects depend on keyword macro expansion in column 1  to create comments?


** Phase 4 Preprocessor tokenization
*** Case sensitive macro names and argument names
:PROPERTIES:
:reqid: [tokens-case-sensitive]
:status: TBD
:source: [C2018§5.2.1 Character sets], [Flpp§1·1]
:tests: [Flpp§pp004.F]
:END:

FPP /is/ case-sensitive when recognizing identifiers even thoughFortran is not case-sensitive
The text fragment
#+begin_src fortran
#define abc XYZ
#define ABC foo
      subroutine abc
#+end_src

should expand to
#+begin_src fortran
      subroutine XYZ
#+end_src

Note that this creates (perhaps astonishing) behavior, such as
#+begin_src fortran
#define ABC var_1
#define abc var_2
      abc = ABC + 1     ! Normally, Fortran treats these as the same identifier
#+end_src

expanding to
#+begin_src fortran
      var_2 = var_1 + 1    ! These identifiers are now different
#+end_src

Fortran programmers may expect it to expand to
#+begin_src fortran
      var_2 = var_2 + 1    ! Only the second definition matters
#+end_src


*** Case sensitive directive names
:PROPERTIES:
:reqid: [dir-case-sensitive]
:status: joryes
:source: [C2018§5.2.1 Character sets], [Flpp§1·1]
:tests: [Flpp§pp004.F]
:END:
*** Case insensitive tokens                                      :noexport:
:PROPERTIES:
:reqid: [tokens-case-insensitive]
:status: jorno
:source: [Flpp§]
:END:

Fortran is not case-sensitive.
The preprocessor is not case-sensitive when recognizing identifiers.
The text fragment
#+begin_src fortran
#define abc XYZ
#define ABC foo
      subroutine abc
#+end_src

should expand to
#+begin_src fortran
      subroutine foo
#+end_src

If the preprocessor were case sensitive, we would have behavior, such as
#+begin_src fortran
#define ABC var_1
#define abc var_2
      abc = ABC + 1     ! Normally, Fortran treats these as the same identifier
#+end_src

expanding to
#+begin_src fortran
      var_2 = var_1 + 1    ! These identifiers are now different
#+end_src

We should expect it to expand to
#+begin_src fortran
      var_2 = var_2 + 1    ! Only the second definition matters
#+end_src


*** Spaces significant in determining tokens
:PROPERTIES:
:reqid: [spaces-end-token]
:status: joryes,
:source: [Flpp§]
:END:

In order to simplify the preprocessor tokenization, spaces are significant, even in fixed-form source.


*** Identifier tokens are not broken by free-form line continuations
:PROPERTIES:
:reqid: [identifiers-span-continuations]
:status: joryes
:source: jor4, [F2023§6.2.2C601]
:tests: [Flpp pp005.F KWM split across continuation, implicit padding], [Flpp pp006.F ditto, but with intervening *comment line]
:END:

In fixed-form, there are only 66 characters available for statement text (columns 7-72). The maximum length of an identifier is 63 characters. It is not practical to have identifiers end at a fixed-form line boundary at column 72.


*** Questions
**** =#if=, =#elif=: Can we tell if =!= is used for comment?

**** =#define= Can we tell if =!= is used as a comment?

**** Examine the unrecognized directives: how to tokenize?


** Phase 5 Directive processing

*** A =#= in column 6 in fixed-form is not a directive
:PROPERTIES:
:reqid: [no-fixed-form-column-6]
:status: TBD
:source: gak, jor4
:END:

We've seen in some existing projects that use =#= in column 6 for a conventional continuation line. These are the Fortran files in [[https://github.com/gklimowicz/fortran-examples][fortran-examples]] that have =#= in column 6. Note that some expect to run through the preprocessor (extension is =.F=).

#+begin_example
ALBUS_ionosphere@twillis449/FORTRAN/IRI/igrf.f
CMAQ@USEPA/POST/sitecmp_dailyo3/src/process.F
E3SM@E3SM-Project/components/mpas-ocean/src/mode_forward/mpas_ocn_time_integration_si.F
Genetic-Algorithm-for-Causeway-Modification@stevenmeyersusf/Code/genmain.f
MCFM-RE@lcarpino/src/Parton/eks98r.f
MITgcm@MITgcm/pkg/openad/externalDummies.F
NCEP_Shared@GEOS-ESM/NCEP_w3/w3ersunb.f
OEDGE@ORNL-Fusion/lim3/comsrc/sysaix.f
PublicRelease_2020@FLOSIC/flosic/scan.f
STELLOPT@PrincetonUniversity/LIBSTELL/Sources/NCLASS/nclass_mod.f
ShirleyForQE@subhayanrc/yambo-stable/src/real_time_common/RT_driver.F
cernlib@apc-llc/2005/src/graflib/higz/imac/f_readwi.F
cernlib@apc-llc/2006/src/graflib/higz/imac/f_readwi.F
cfdtools@nasa/app/traj_opt/numerics.f
cfdtools@nasa/lib/searchlib/hsortcc.f
dynamite@dynamics-of-stellar-systems/legacy_fortran/galahad-2.3/src/ma27/ma27d.f
forestclaw@ForestClaw/applications/clawpack/euler/2d/rp/rpn2euq3.f
hompack90@vtopt/src/MAINP.f
legacy-mars-global-climate-model@nasa/code/cmp3out.f
nosofs-NCO@ioos/sorc/SELFE.fd/utility/Combining_Scripts/combine_outHA.f
nwchem@nwchemgit/src/nwpw/band/lib/psi/cpsi_KS.F
nwchem@nwchemgit/src/tce/mrcc/tce_mrcc_energy.F
pyOpt@madebr/pyOpt/pySLSQP/source/slsqp.f
pyclaw@clawpack/development/rp_approaches/rpn2_euler_5wave.f
scream@E3SM-Project/components/mpas-ocean/src/mode_forward/mpas_ocn_time_integration_si.F
starlink@Starlink/applications/echomop/ech_kdhsubs.f
starlink@Starlink/applications/obsolete/iras90/misc/ffield.f
starlink@Starlink/thirdparty/caltech/pgplot/examples/pgdemo17.f
#+end_example


*** # non-directive
:PROPERTIES:
:reqid: [non-directive]
:status: TBD
:source: [C§6.10 Preprocessing directives]
:END:

*** Conditional inclusion
**** # if /constant-expression/
:PROPERTIES:
:reqid: [#if]
:status: TBD
:source: [C§6.10.1 Conditional inclusion]
:END:


**** # ifdef /identifier/
:PROPERTIES:
:reqid: [#ifdef]
:status: TBD
:source: [C§6.10.1 Conditional inclusion]
:END:


**** # ifndef /identifier/
:PROPERTIES:
:reqid: [#ifndef]
:status: TBD
:source: [C§6.10.1 Conditional inclusion]
:END:


**** # elif /constant-expression/
:PROPERTIES:
:reqid: [#elif]
:status: TBD
:source: [C§6.10.1 Conditional inclusion]
:END:


**** # else
:PROPERTIES:
:reqid: [#else]
:status: TBD
:source: [C§6.10.1 Conditional inclusion]
:END:


**** # endif
:PROPERTIES:
:reqid: [#endif]
:status: TBD
:source: [C§6.10.1 Conditional inclusion]
:END:


*** Source file inclusion
**** # include /char-literal-constant/
:PROPERTIES:
:reqid: [#include]
:status: TBD
:source: [C§6.10.2 Source file inclusion], [F2023§7.4.4.3 Character literal constant], [F2023§6.4 Including source text]
:END:


**** # include /pp-tokens/
:PROPERTIES:
:reqid: [#include-computed]
:status: TBD
:source: [C§6.10.2 Source file inclusion]
:END:


*** Macro replacement
**** # define id replacement-list
:PROPERTIES:
:reqid: [#define-id]
:status: TBD
:source: [C§6.10.3 Macro replacement]
:END:


**** # define id ( id-list ) replacement-list
:PROPERTIES:
:reqid: [#define-id-function]
:status: TBD
:source: [C§6.10.3 Macro replacement]
:END:


**** # define id ( ... ) replacement-list
:PROPERTIES:
:reqid: [#define-id-0-varargs]
:status: TBD
:source: [C§6.10.3 Macro replacement]
:END:


**** # define id ( id-list , ... ) replacement-list
:PROPERTIES:
:reqid: [#define-id-n-varargs]
:status: TBD
:source: [C§6.10.3 Macro replacement]
:END:


**** # undef
:PROPERTIES:
:reqid: [#undef]
:status: TBD
:source: [C§6.10.3.5 Macro replacement]
:END:


*** Line control
**** # line
:PROPERTIES:
:reqid: [#line]
:status: TBD
:source: [C§6.10.4 Line control]
:END:


*** Error directive
**** # error
:PROPERTIES:
:reqid: [#error]
:status: TBD
:source: [C§6.10.5 Error directive]
:END:

*** Error directive
**** # warning
:PROPERTIES:
:reqid: [#warning]
:status: TBD
:source: [C§6.10.5 Error directive]
:END:

*** Pragma directive
**** # pragma
:PROPERTIES:
:reqid: [#pragma]
:status: TBD
:source: [C§6.10.6 Pragma directive]
:END:


*** Null directive

**** # newline
:PROPERTIES:
:reqid: [#null]
:status: TBD
:source: [C§6.10.7 Null directive]
:END:


*** Additional requests
**** # show
:PROPERTIES:
:reqid: [#show]
:status: TBD
:source: lio3, [C§6.10 Preprocessing directives]
:END:

#+begin_quote
#show prints a table of all the macros; and a "#show namea nameb name*" does the same with just the listed names, but allows simple globbing. Simple and sometimes useful for distinguishing between output files when actually retaining the intermediate files. All the output is written to the output file with lines starting with ! (not standard, but even a lot of pre-f90 compilers allowed ! as a comment)

so the output is still valid Fortran.
#+end_quote


**** # import VARNAME
:PROPERTIES:
:reqid: [#import]
:status: TBD
:source: lio3, [C§6.10 Preprocessing directives]
:END:

#+begin_quote
which imports an environment variable as if it had been defined with -DVARNAME=VALUE
#+end_quote


**** # output filename [--append]
:PROPERTIES:
:reqid: [#output]
:status: TBD
:source: lio3, [C§6.10 Preprocessing directives]
:END:

#+begin_quote
which makes it easy to have a single file that outputs Fortran, C, markdown ... sections but would complicate a preprocessor being "inline" in the compiler, which I hope is an expected feature of a standard preprocessor, thus being able to eliminate having to generate (or at least retain) intermediate files, being able to define reusable blocks of plain test and reuse them or loop over them applying an optional filter that can convert them all to comments, convert them all the a character variable definition, or convert them to WRITE statements. Makes maintaining comments and help text a lot easier, as you can just type it as plain text, for example. I would be content with just cpp-like functionality, but those are features I use a lot cpp(1) does not do, except typically (not in all fpp flavors) block comments are supported. I think a #import would be useful and simple though. Perhaps a group concensus would be it is problematic, making sure it is not inadvertently the wrong value, ... so not sure even that would make it into a first-generation standard utility.
#+end_quote


*** Predefined macros

**** =__FILE__= Current file name
:PROPERTIES:
:reqid: [macro-file-name-context]
:status: TBD
:source: [C§6.10.8 Predefined macro names]
:END:


**** =__LINE__= Current line number
:PROPERTIES:
:reqid: [macro-line-number-context]
:status: TBD
:source: [C§6.10.8 Predefined macro names]
:END:


**** =__STDF__= Fortran compiler (1)
:PROPERTIES:
:reqid: [macro-stdf]
:status: TBD
:source: fa[C§6.10.8 Predefined macro names]
:END:


**** =__STDF_HOSTED__= Compiler is hosted cross-compiler (e.g., 202311)
:PROPERTIES:
:reqid: [macro-stdf-hosted]
:status: Not accepted
:source: fa[C§6.10.8 Predefined macro names]
:END:


**** =__STDF_VERSION__= Fortran standard conformance
:PROPERTIES:
:reqid: [macro-stdf-version]
:status: TBD
:source: fa[C§6.10.8 Predefined macro names]
:END:


**** =__DATE__= of processing
:PROPERTIES:
:reqid: [macro-file-process-date]
:status: TBD
:source: [C§6.10.8 Predefined macro names]
:END:


**** =__TIME__= time of processing
- Source :::
:PROPERTIES:
:reqid: [macro-file-process-time]
:status: TBD
:source: [C§6.10.8 Predefined macro names]
:END:


**** =STRINGIFY= macro function
:PROPERTIES:
:reqid: [macro-stringify-function]
:status: JoR No
:source: clu1
:END:

Tom Clune requested a macro named =stringify=, which apparently is commonly used in some codes. There is no stadard =stringify= macro, so JoR declined to add one.


**** =__SCOPE__= defines current lexical scope
:PROPERTIES:
:reqid: [macro-lexical-scope-name]
:status: JoR No
:source: clu1, lio1
:END:


**** =__VENDOR__=
:PROPERTIES:
:reqid: [macro-vendor-name]
:status: Not accepted
:source: clu1
:END:


**** No undecorated names (no =_=) defined by preprocessor
:PROPERTIES:
:reqid: [macro-no-undecorated]
:status: TBD
:source: lio2
:END:

*** Expressions

**** =#=
:PROPERTIES:
:reqid: [#-operator]
:status: TBD
:source: [C§6.10.3.2 The # operator]
:END:


**** =##=
:PROPERTIES:
:reqid: [##-operator]
:status: TBD
:source: [C§6.10.3.3 The ## operator]
:END:


**** =defined= /identifier/
:PROPERTIES:
:reqid: [defined-operator]
:status: TBD
:source: [C§6.10.1 Conditional inclusion]
:END:


**** =defined= =(= /identifier/ =)=
:PROPERTIES:
:reqid: [defined-operator]
:status: TBD
:source: [C§6.10.1 Conditional inclusion]
:END:


**** =!=
:PROPERTIES:
:reqid: [bang-operator]
:status: TBD
:source: [C§6.10 Preprocessing directives]
:END:


**** [c-expressions] C-style expressions
- Source :::
:PROPERTIES:
:status: TBD, [C§6.10 Preprocessing directives]
:END:

This is problematic, in that there are many files in the wild that have the =!= not operator in =#if= and =#elif= directives. This is a Fortran comment character.


**** [fortran-expressions] Fortran-style expressions
- Source :::
:PROPERTIES:
:status: TBD, [C§6.10 Preprocessing directives]
:END:



*** Expansion
**** No expansion of =C= in column 1
:PROPERTIES:
:reqid: [fixed-no-expand-c-col-1]
:status: TBD
:source: ble1, [C§6.10 Preprocessing directives]
:END:

In fixed-form, =C= or =c= in column 1 indicates a comment.
No identifier that begins with a =C= or =c= in column 1 is expanded.


**** No expansion of =D= in column 1
:PROPERTIES:
:reqid: [fixed-no-expand-d-col-1]
:status: TBD
:source: ble1, [Flpp§], [C§6.10 Preprocessing directives]
:END:

In fixed-form, =D= in column 1 is a common extension to indicate a comment.
No identifier that begins with a =D= in column is expanded.


**** No expansion of column 6
:PROPERTIES:
:reqid: [fixed-no-expand-col-6]
:status: TBD
:source: gak, [C§6.10 Preprocessing directives]
:END:

In fixed-form, a character in column 6 that is not blank or zero indicates a continuation line.
No identifier that begins in column 6 is expanded.

[Note that since we define expansion to occur after continuation handling, this requirement is not necessary.]


**** Strip column 1 =C= comments from expanded text
:PROPERTIES:
:reqid: [fixed-strip-col-1-comments]
:status: TBD
:source: [Flpp§], [C§6.10 Preprocessing directives]
:END:


**** Pass comments from expanded text to the processor
:PROPERTIES:
:reqid: [pass-comments]
:status: TBD
:source: [Flpp§]
:END:

This is necessary to pass comments with directives to the Fortran processor.


**** No expansion of function macro names not followed by parenthesis
:PROPERTIES:
:reqid: [no-expand-function-non-function]
:status: TBD
:source: [C§6.10 Preprocessing directives], [G14§3.3 Macro Arguments]
:END:

String constants are output without being examined for macro expansion.


**** Function macro name invocation may cross logical line boundaries
:PROPERTIES:
:reqid: [expand-function-macro-invocation-multiline]
:status: TBD
:source: [C§6.10 Preprocessing directives], [G§3.3 Macro Arguments], [G14§3.10.5 Self-Referential Macros]
:END:

String constants are output without being examined for macro expansion.


**** No expansion of self-referential macro names
:PROPERTIES:
:reqid: [no-expand-self-reference]
:status: TBD
:source: [C§6.10 Preprocessing directives], [G14§3.10.5 Self-Referential Macros]
:END:

String constants are output without being examined for macro expansion.


**** No expansion in strings
:PROPERTIES:
:reqid: [no-expand-string]
:status: TBD
:source: ble1, [Flpp§], [C§6.10 Preprocessing directives]
:END:

String constants are output without being examined for macro expansion.


**** No expansion in Hollerith
:PROPERTIES:
:reqid: [no-expand-hollerith]
:status: TBD
:source: ble1, [C§6.10 Preprocessing directives]
:END:

No expansion occurs in the string contained in a Hollerith constant.


**** No expansion in =IMPLICIT= single-character specifiers
:PROPERTIES:
:reqid: [no-expand-implicit-char-list]
:status: TBD
:source: ble1
:END:

The letters in an =IMPLICIT= statement are not considered for macro expansion.

Note that this implies the preprocessor recognizes =IMPLICIT= statements.


**** No expansion in =FORMAT= specifiers
:PROPERTIES:
:reqid: [no-expand-format]
:status: TBD
:source: ble1, [Flpp§], [F20123§13.2.1R1301]
:END:

In =FORMAT= statements, there is no macro expansion in the /format-specification/..

Note that this implies the preprocessor recognizes =FORMAT= statements.


**** Expansion in comments
:PROPERTIES:
:reqid: [expand-comments]
:status: TBD
:source: ble1
:END:

Outside the exceptions noted elsewhere, the preprocessor expands macros in the text of comments.

[This may be the way the preprocessor preserves directives (such as OpenMP and OpenACC) in the program. We have heard from at least one J3 member that this is on important feature. The good news is that expanding macros always will handle directives, without having to do special processing for all manner of directives. The other good news in that comments without directives are ignored by the processor, so we don't care (maybe) how they are mangled.]


**** Expansion in directives (e.g., OpenMP)
:PROPERTIES:
:reqid: [expand-directives]
:status: TBD
:source: ble1
:END:

This is problematic, as how does the preprocessor know which comments are directives?


**** Expand =INCLUDE= lines as if =#include=
:PROPERTIES:
:reqid: [preprocess-fortran-include]
:status: TBD
:source: [Flpp§], jor1, JoR4
:END:

Assuming the preprocessor is a mandatory part of the Fortran standard, preprocessor directives are allowed in the file specified in a Fortran =INCLUDE= line. Therefore, the preprocessor should process the =INCLUDE=-ed file as if it had been invoked via the =#include= directive.

Otherwise, where will the handling of directives the included file be handled, and how can it use any of the macro definitions available at the time the =INCLUDE= statement is encountered. (It is likely to be included in multiple places in the application.)


**** Expand macro names in /kind-param/ in literal constants
:PROPERTIES:
:reqid: [expand-kind-param]
:status: TBD
:source: JoR3, [F2023§7.4.3.1R709 Integer type], [F2023§7.4.3.2R714 Real type], [F2023§7.4.4.3R724 Character literal constant], [F2023§7.4.5R725 Logical type]
:END:

If the /kind-param/ is a /scalar-int-constant-name/ following the underscore in an /int-literal-constant/, /real-literal-constant/, and /logical-literal-constant/, that constant name is subject to macro expansion. This needs to be explicit, as otherwise the preprocessor might treat =_kind-name= as an identifier, as many preprocesser predefined macro names begin with an underscore.

In a /char-literal-constant/, if the /kind-param/ preceding the underscore (=_=) is a /scalar-int-constant-name/, that constant name is subject to macro expansion. This needs to be explicit, as otherwise the preprocessor might treat =kind-name_= as an identifier.

***  Output form
The user may request the preprocessor to produce the source representation after preprocessing. How this is requested is processor-dependent. If provided, the source form of the preprocessor output shall be bound by the following requirements.

**** =#line= and =#file= directives in the output
:PROPERTIES:
:reqid: [output-provenance-directives]
:status: TBD
:source: [Flpp§], jor4, [F2023§6.3.2 Free source form]
:END:

To show source code origin information (such as for error messages), the preprocessor may generate such origin information in the form of =#line= and =#file= directives. These directive lines may be up to 10,000 characters long, as in free-form Fortran input.


**** Directive lines begin with a =#= in column 1
:PROPERTIES:
:reqid: [output-directives-column-1]
:status: TBD
:source: [Flpp§], jor4, [F2023§6.3.3 Fixed source form]
:END:


**** Fixed-form input becomes fixed-form output
:PROPERTIES:
:reqid: [output-fixed-to-fixed]
:status: TBD
:source: [Flpp§], jor4, [F2023§6.3.3 Fixed source form]
:END:

When the preprocessor produces output corresponding to fixed-form Fortran input (such as with the =-E= option supported by some C compilers), it must produce valid Fortran fixed-form source code. This may require re-flowing the preprocessed output to the 72-column boundary.

- Column 1 :: Comments begin with a =C= or =c= in column 1.
- Columns 1-5 :: Optional statement label.
- Column 6 :: =0= or blank if not a continuation; continuation line otherwise.
- Columns 7-72 :: Fortran statement text


**** Free-form input becomes free-form output
:PROPERTIES:
:reqid: [output-free-to-free]
:status: TBD
:source: [Flpp§], [F2023§6.3.2 Free source form]
:END:

When the preprocessor produces output corresponding to free-form Fortran input (such as with the =-E= option supported by some C compilers), it must produce valid free-form Fortran source code. This may require re-flowing the preprocessed output to the 10,000-column boundary.

- Columns 1-10,000 :: Up to 10,000 characters of Fortran source text. If the source text is longer than 10,000 characters, up to 9,999 characters followed by =&= to continue additional source text on the next physical line, continuing up until one million characters of Fortran source.



** Phase 6 Convert preprocessing tokens to tokens
With a suitable representation for preprocessing tokens, this phase may be unnecessary.



* Further investigation of existing Fortran projects

** Add directives found inside =#include= files

** Add directives found inside =INCLUDE= files
** Add whether directives found inside =INCLUDE= files

** What projects depend on case-sensitive macro replacement?

** What projects depend on not expanding in =INCLUDE= files (besides VASP)?

** What projects depend on not preprocessing =INCLUDE= files


# [[bibliographystyle:apalike]]
# [[bibliography:references.bib]]


* Links                                                            :noexport:
- [[id:B95B266B-EC1E-44C8-B1F3-ABE74A38D9A3][Review specification for C preprocessor from standard C reference]]
- [[id:D5905323-2724-4ABB-A0D2-2F5973455240][J3 JoR meeting re preprocessor 20220822-1000]]
- [[id:C5448143-9FF2-4E7D-B939-FCA13386BB26][J3 JoR meeting re preprocessor 20220920-1300]]
- [[id:11681178-42A9-41D5-B562-3F25B7049C04][Notes on Fortran preprocessor fppTutorial2 from Rich Bleikamp 2022-09-08]]
- [[fpp:requirements/Consolidated requirements for Fortran preprocessor for Fortran 202y.org]]


* Text I am not using any more                                     :noexport:
** Translation phases
Similar to the C standard, we define phases of text processing related to preprocessing. The preprocessor performs the following phases on the input source program before the processor transforms the program for use.

This requires implementations to behave as if these separate preprocessing phases occur, even though they are typically folded together in practice. Source input need not necessarily be stored as files, nor need there be any one-to-one correspondence between these entities and any external representation. The description is conceptual only, and does not specify any particular implementation.

1. Continuation lines in the input source are interpreted, producing a sequence of logical lines (introducing new-line characters for end-of-line indicators). [C§5.1.1.2¶1·1-2]
2. The preprocessor decomposes the logical lines into preprocessing tokens and sequences of white-space characters and comments. This input shall not end in a partial preprocessing token. New-line characters are retained. For the proper handling of compiler directives, comments are retained. Whether each nonempty sequence of white-space characters other than new-line is retained or replaced by one space character is implementation-defined. [C§5.1.1.2¶1·3]
3. Preprocessing directives are executed and macro invocations are expanded. A #include preprocessing directive causes the named header or source file to be processed from phase 1 through phase 3, recursively. All preprocessing directives are then deleted. [C§5.1.1.2¶1·4]
4. Each preprocessing token is converted into a token for subsequent handling by the processor.

** Vestigial requirements
**** No right margin clipping on directive lines
:PROPERTIES:
:reqid: [fixed-no-directive-clip]
:status: TBD
:source: [Flpp§]
:END:


**** Expanded text reflects fixed-format rules for fixed-form input
:PROPERTIES:
:reqid: [fixed-output-conform]
:status: TBD
:source: [Flpp§], jor4
:END:
