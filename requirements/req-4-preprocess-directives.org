:PROPERTIES:
:ID:       20241123T190939.723895
:END:
#+title: FPP Phase 4 -- Preprocess Directives
#+author: INCITS/Fortran JoR
#+date: November 26, 2024
#+options: toc:nil
#+startup: showall
#+include: "latex-options.org"
#+options: toc:t H:5 num:4

#  LocalWords:  Clu Lio Ble Kli Fortranized Jor VARNAME


* Introduction
The INCITS/Fortran committee has discussed several times in the Plenary meetings, and the JoR subgroup has met several times, to lay down formal requirements for the proposed Fortran preprocessor (FPP) for Fortran 202y (presumably 2028).

This paper lists the requirements and syntax for Phase 4 of the preprocessor, which processes directives after Phase 3 tokenizes the input stream.

#+include: "req-inc-phase-list.org" :only-contents :minlevel 1


* High-level requirements
Steve Lionel, the ISO WG 5 (Fortran) Convenor, presented this list of high-level requirements at INCITS/Fortran meeting #232, February 2024 [[cite:&j3-jor-2024-preproc-take-2]]

Fortran programmers use preprocessing for several reasons:
- Adjusting external names for C interoperability (largely obviated by C interop features in the language)
- Platform/OS specific code
- Debug or other variants of code
- A crude way of implementing templates

Explicit goals for Fortran 202y were
- Define cpp-style preprocessor in the standard
- Ideally, most existing uses of preprocessing will "just work", or need minimal changes
- Feature will not be optional, but implementations are encouraged to offer an option to "do it the old way"
- "Minimum Viable Product" – don't try to do everything

Features should have the same semantics as the C preprocessor, except as noted.
- =__LINE__= and =__FILE__= defined macros
- =#line=
- =#ifdef=, =#ifndef=, =#endif=
- =#if=, =#elif=, =#else=, =#endif=
- =#define= and =#undef=
- =#include=
- =#error=
- =#= operator (character literal from token)
- =##= operator (token concatenation)
- =/* ... */= C-style comments are allowed in directives (including multi-line comments)
- =\= new-line continuations allowed in directives
- =#pragma= directive for implementation-specific directives

- Macro expansion
    - tokens are case-sensitive
    - tokens are not replaced in character literals
    - tokens are not replaced in Hollerith strings
    - tokens are not replaced in /letter-spec-list/ of =IMPLICIT= statements
    - tokens are not replaced in column 6 in fixed-form source
    - tokens are replaced in comment-style directives (such as =!omp$=, =!dir$=)

- Expressions
    - =defined= operator
    - =//= is the Fortran concatenation operator; it does not introduce a C-style comment
    - =!= is the C ``not'' operator; it does not introduce a Fortran comment


* Detailed requirements
We list the detailed requirements for handling preprocessor directives.

Each requirement is a heading with a ``One-line description'', followed by a short table that contains  a unique identifier, the requirement's current status in the INCITS/Fortran approval process, and where the requirement came from (such as a C or Fortran standard, an INCITS meeting, or on email conversation).

[Note: Most of the detailed requirements here are still being worked...]

#+include: "req-inc-sources.org" :only-contents :minlevel 2


** # non-directive                                          :noexport:
|-----------------+--------+-----------------------------------|
| *ID*              | *Status* | *Sources*                           |
|-----------------+--------+-----------------------------------|
| [non-directive] | TBD    | [C§6.10 Preprocessing directives] |
|-----------------+--------+-----------------------------------|


** Conditional inclusion                                          :noexport:
*** # if /constant-expression/
|-------+--------+----------------------------------|
| *ID*    | *Status* | *Sources*                          |
|-------+--------+----------------------------------|
| [#if] | TBD    | [C§6.10.1 Conditional inclusion] |
|-------+--------+----------------------------------|



*** # ifdef /identifier/
|----------+--------+----------------------------------|
| *ID*       | *Status* | *Sources*                          |
|----------+--------+----------------------------------|
| [#ifdef] | TBD    | [C§6.10.1 Conditional inclusion] |
|----------+--------+----------------------------------|


*** # ifndef /identifier/
|-----------+--------+----------------------------------|
| *ID*        | *Status* | *Sources*                          |
|-----------+--------+----------------------------------|
| [#ifndef] | TBD    | [C§6.10.1 Conditional inclusion] |
|-----------+--------+----------------------------------|


*** # elif /constant-expression/
|---------+--------+----------------------------------|
| *ID*    | *Status* | *Sources*                          |
|---------+--------+----------------------------------|
| [#elif] | TBD    | [C§6.10.1 Conditional inclusion] |
|---------+--------+----------------------------------|


*** # else
|---------+--------+----------------------------------|
| *ID*      | *Status* | *Sources*                          |
|---------+--------+----------------------------------|
| [#else] | TBD    | [C§6.10.1 Conditional inclusion] |
|---------+--------+----------------------------------|


*** # endif
|----------+--------+----------------------------------|
| *ID*       | *Status* | *Sources*                          |
|----------+--------+----------------------------------|
| [#endif] | TBD    | [C§6.10.1 Conditional inclusion] |
|----------+--------+----------------------------------|


** Source file inclusion                                          :noexport:
*** # include /char-literal-constant/
|------------+--------+--------------------------------------------|
| *ID*         | *Status* | *Sources*                                    |
|------------+--------+--------------------------------------------|
| [#include] | TBD    | [C§6.10.2 Source file inclusion]           |
|            |        | [F2023§7.4.4.3 Character literal constant] |
|            |        | [F2023§6.4 Including source text]          |
|------------+--------+--------------------------------------------|


*** # include /pp-tokens/
|---------------------+--------+----------------------------------|
| *ID*                  | *Status* | *Sources*                          |
|---------------------+--------+----------------------------------|
| [#include-computed] | TBD    | [C§6.10.2 Source file inclusion] |
|---------------------+--------+----------------------------------|


** Macro definition                                               :noexport:
*** # define id replacement-list
|--------------+--------+------------------------------|
| *ID*           | *Status* | *Sources*                      |
|--------------+--------+------------------------------|
| [#define-id] | TBD    | [C§6.10.3 Macro replacement] |
|--------------+--------+------------------------------|


*** # define id ( id-list ) replacement-list
|-----------------------+--------+------------------------------|
| *ID*                    | *Status* | *Sources*                      |
|-----------------------+--------+------------------------------|
| [#define-id-function] | TBD    | [C§6.10.3 Macro replacement] |
|-----------------------+--------+------------------------------|


*** # define id ( ... ) replacement-list
|------------------------+--------+------------------------------|
| *ID*                     | *Status* | *Sources*                      |
|------------------------+--------+------------------------------|
| [#define-id-0-varargs] | TBD    | [C§6.10.3 Macro replacement] |
|------------------------+--------+------------------------------|


*** # define id ( id-list , ... ) replacement-list
|------------------------+--------+------------------------------|
| *ID*                     | *Status* | *Sources*                      |
|------------------------+--------+------------------------------|
| [#define-id-n-varargs] | TBD    | [C§6.10.3 Macro replacement] |
|------------------------+--------+------------------------------|


*** # undef
|----------+--------+--------------------------------|
| *ID*       | *Status* | *Sources*                        |
|----------+--------+--------------------------------|
| [#undef] | TBD    | [C§6.10.3.5 Macro replacement] |
|----------+--------+--------------------------------|


** Line control                                          :noexport:
*** # line
|---------+--------+-------------------------|
| *ID*      | *Status* | *Sources*                 |
|---------+--------+-------------------------|
| [#line] | TBD    | [C§6.10.4 Line control] |
|---------+--------+-------------------------|


** Error directive                                          :noexport:
*** # error
|----------+--------+----------------------------|
| *ID*       | *Status* | *Sources*                    |
|----------+--------+----------------------------|
| [#error] | TBD    | [C§6.10.5 Error directive] |
|----------+--------+----------------------------|

*** # warning
|------------+--------+----------------------------|
| *ID*         | *Status* | *Sources*                    |
|------------+--------+----------------------------|
| [#warning] | TBD    | [C§6.10.5 Error directive] |
|------------+--------+----------------------------|


** Pragma directive                                          :noexport:
*** # pragma
|-----------+--------+-----------------------------|
| *ID*        | *Status* | *Sources*                     |
|-----------+--------+-----------------------------|
| [#pragma] | TBD    | [C§6.10.6 Pragma directive] |
|-----------+--------+-----------------------------|


** Null directive                                          :noexport:

*** # newline
|------------+--------+---------------------------|
| *ID*         | *Status* | *Sources*                   |
|------------+--------+---------------------------|
| [#newline] | TBD    | [C§6.10.7 Null directive] |
|------------+--------+---------------------------|


** Predefined macros                                          :noexport:

*** =__FILE__= Current file name
|---------------------------+--------+-----------------------------------|
| *ID*                        | *Status* | *Sources*                           |
|---------------------------+--------+-----------------------------------|
| [macro-file-name-context] | TBD    | [C§6.10.8 Predefined macro names] |
|---------------------------+--------+-----------------------------------|


*** =__LINE__= Current line number
|-----------------------------+--------+-----------------------------------|
| *ID*                          | *Status* | *Sources*                           |
|-----------------------------+--------+-----------------------------------|
| [macro-line-number-context] | TBD    | [C§6.10.8 Predefined macro names] |
|-----------------------------+--------+-----------------------------------|


*** =__STDFORTRAN__= Fortran compiler (1)
|--------------+--------+-------------------------------------|
| *ID*           | *Status* | *Sources*                             |
|--------------+--------+-------------------------------------|
| [macro-stdf] | TBD    | fa[C§6.10.8 Predefined macro names] |
|--------------+--------+-------------------------------------|


*** =__STDF_HOSTED__= Compiler is hosted cross-compiler (e.g., 202311)
|---------------------+--------------+-------------------------------------|
| *ID*                  | *Status*       | *Sources*                             |
|---------------------+--------------+-------------------------------------|
| [macro-stdf-hosted] | Not accepted | fa[C§6.10.8 Predefined macro names] |
|---------------------+--------------+-------------------------------------|


*** =__STDFORTRAN_VERSION__= Fortran standard conformance
|----------------------+--------+-------------------------------------|
| *ID*                   | *Status* | *Sources*                             |
|----------------------+--------+-------------------------------------|
| [macro-stdf-version] | TBD    | fa[C§6.10.8 Predefined macro names] |
|----------------------+--------+-------------------------------------|


*** =__DATE__= of processing
|---------------------------+--------+-----------------------------------|
| *ID*                        | *Status* | *Sources*                           |
|---------------------------+--------+-----------------------------------|
| [macro-file-process-date] | TBD    | [C§6.10.8 Predefined macro names] |
|---------------------------+--------+-----------------------------------|


*** =__TIME__= time of processing
|---------------------------+--------+-----------------------------------|
| *ID*                        | *Status* | *Sources*                           |
|---------------------------+--------+-----------------------------------|
| [macro-file-process-time] | TBD    | [C§6.10.8 Predefined macro names] |
|---------------------------+--------+-----------------------------------|


*** =STRINGIFY= macro function
|----------------------------+--------+---------|
| *ID*                         | *Status* | *Sources* |
|----------------------------+--------+---------|
| [macro-stringify-function] | JoR No | clu1    |
|----------------------------+--------+---------|

Tom Clune requested a macro named =stringify=, which apparently is commonly used in some codes. There is no stadard =stringify= macro, so JoR declined to add one.


*** =__SCOPE__= defines current lexical scope
|----------------------------+--------+------------|
| *ID*                         | *Status* | *Sources*    |
|----------------------------+--------+------------|
| [macro-lexical-scope-name] | JoR No | clu1, lio1 |
|----------------------------+--------+------------|


*** =__VENDOR__=
|---------------------+--------------+---------|
| *ID*                  | *Status*       | *Sources* |
|---------------------+--------------+---------|
| [macro-vendor-name] | Not accepted | clu1    |
|---------------------+--------------+---------|


*** No undecorated names (no =_=) defined by preprocessor
|------------------------+--------+---------|
| *ID*                     | *Status* | *Sources* |
|------------------------+--------+---------|
| [macro-no-undecorated] | TBD    | lio2    |
|------------------------+--------+---------|


** Expressions                                          :noexport:

*** =#=
|--------------+--------+-----------------------------|
| *ID*           | *Status* | *Sources*                     |
|--------------+--------+-----------------------------|
| [#-operator] | TBD    | [C§6.10.3.2 The # operator] |
|--------------+--------+-----------------------------|


*** =##=
|---------------+--------+------------------------------|
| *ID*            | *Status* | *Sources*                      |
|---------------+--------+------------------------------|
| [##-operator] | TBD    | [C§6.10.3.3 The ## operator] |
|---------------+--------+------------------------------|


*** =defined= /identifier/
|--------------------+--------+----------------------------------|
| *ID*                 | *Status* | *Sources*                          |
|--------------------+--------+----------------------------------|
| [defined-operator] | TBD    | [C§6.10.1 Conditional inclusion] |
|--------------------+--------+----------------------------------|


*** =defined= =(= /identifier/ =)=
|--------------------+--------+----------------------------------|
| *ID*                 | *Status* | *Sources*                          |
|--------------------+--------+----------------------------------|
| [defined-operator] | TBD    | [C§6.10.1 Conditional inclusion] |
|--------------------+--------+----------------------------------|


*** =!=
|-----------------+--------+-----------------------------------|
| *ID*              | *Status* | *Sources*                           |
|-----------------+--------+-----------------------------------|
| [bang-operator] | TBD    | [C§6.10 Preprocessing directives] |
|-----------------+--------+-----------------------------------|


*** [c-expressions] C-style expressions
|-----------------+--------+-----------------------------------|
| *ID*              | *Status* | *Sources*                           |
|-----------------+--------+-----------------------------------|
| [c-expressions] | TBD    | [C§6.10 Preprocessing directives] |
|-----------------+--------+-----------------------------------|


*** [fortran-expressions] Fortran-style expressions
|-----------------------+--------+-----------------------------------|
| *ID*                    | *Status* | *Sources*                           |
|-----------------------+--------+-----------------------------------|
| [fortran-expressions] | TBD    | [C§6.10 Preprocessing directives] |
|-----------------------+--------+-----------------------------------|



** Expansion

*** No expansion of function macro names not followed by parenthesis
|-----------------------------------+--------+-----------------------------------|
| *ID*                                | *Status* | *Sources*                           |
|-----------------------------------+--------+-----------------------------------|
| [no-expand-function-non-function] | TBD    | [C§6.10 Preprocessing directives] |
|                                   |        | [G14§3.3 Macro Arguments]         |
|-----------------------------------+--------+-----------------------------------|

String constants are output without being examined for macro expansion.


*** Function macro invocation may cross logical line boundaries
|-----------------------------------+--------+--------------------------------------|
| *ID*                                | *Status* | *Sources*                              |
|-----------------------------------+--------+--------------------------------------|
| [expand-function-macro-multiline] | TBD    | [C§6.10 Preprocessing directives]    |
|                                   |        | [G§3.3 Macro Arguments]              |
|                                   |        | [G14§3.10.5 Self-Referential Macros] |
|-----------------------------------+--------+--------------------------------------|

String constants are output without being examined for macro expansion.


*** No expansion of self-referential macro names
|----------------------------+--------+--------------------------------------|
| *ID*                         | *Status* | *Sources*                              |
|----------------------------+--------+--------------------------------------|
| [no-expand-self-reference] | TBD    | [C§6.10 Preprocessing directives]   |
|                            |        | [G14§3.10.5 Self-Referential Macros] |
|----------------------------+--------+--------------------------------------|

String constants are output without being examined for macro expansion.


*** No expansion in strings
|--------------------+--------+-----------------------------------|
| *ID*                 | *Status* | *Sources*                           |
|--------------------+--------+-----------------------------------|
| [no-expand-string] | TBD    | ble1, [Flpp§]                     |
|                    |        | [C§6.10 Preprocessing directives] |
|--------------------+--------+-----------------------------------|

String constants are output without being examined for macro expansion.


*** No expansion in Hollerith
|-----------------------+--------+-----------------------------------|
| *ID*                    | *Status* | *Sources*                           |
|-----------------------+--------+-----------------------------------|
| [no-expand-hollerith] | TBD    | ble1                              |
|                       |        | [C§6.10 Preprocessing directives] |
|-----------------------+--------+-----------------------------------|

No expansion occurs in the string contained in a Hollerith constant.


*** No expansion in =IMPLICIT= single-character specifiers
|--------------------------------+--------+---------|
| *ID*                             | *Status* | *Sources* |
|--------------------------------+--------+---------|
| [no-expand-implicit-char-list] | TBD    | ble1    |
|--------------------------------+--------+---------|

The letters in an =IMPLICIT= statement are not considered for macro expansion.

Note that this implies the preprocessor recognizes =IMPLICIT= statements.


*** No expansion in =FORMAT= specifiers
|--------------------+--------+----------------------|
| *ID*                 | *Status* | *Sources*              |
|--------------------+--------+----------------------|
| [no-expand-format] | TBD    | ble1,                |
|                    |        | [Flpp§]              |
|                    |        | [F20123§13.2.1R1301] |
|--------------------+--------+----------------------|

In =FORMAT= statements, there is no macro expansion in the /format-specification/..

Note that this implies the preprocessor recognizes =FORMAT= statements.


*** Expand =INCLUDE= lines as if =#include=
|------------------------------+--------+---------------------|
| *ID*                           | *Status* | *Sources*             |
|------------------------------+--------+---------------------|
| [preprocess-fortran-include] | TBD    | [Flpp§], jor1, JoR4 |
|------------------------------+--------+---------------------|

Assuming the preprocessor is a mandatory part of the Fortran standard, preprocessor directives are allowed in the file specified in a Fortran =INCLUDE= line. Therefore, the preprocessor should process the =INCLUDE=-ed file as if it had been invoked via the =#include= directive.

Otherwise, where will the handling of directives the included file be handled, and how can it use any of the macro definitions available at the time the =INCLUDE= statement is encountered. (It is likely to be included in multiple places in the application.)


*** Expand macro names in /kind-param/ in literal constants
|---------------------+--------+-------------------------------------------------|
| *ID*                  | *Status* | *Sources*                                         |
|---------------------+--------+-------------------------------------------------|
| [expand-kind-param] | TBD    | JoR3                                            |
|                     |        | [F2023§7.4.3.1R709 Integer type]                |
|                     |        | [F2023§7.4.3.2R714 Real type]                   |
|                     |        | [F2023§7.4.4.3R724 Character literal constant], |
|                     |        | [F2023§7.4.5R725 Logical type]                  |
|---------------------+--------+-------------------------------------------------|

If the /kind-param/ is a /scalar-int-constant-name/ following the underscore in an /int-literal-constant/, /real-literal-constant/, and /logical-literal-constant/, that constant name is subject to macro expansion. This needs to be explicit, as otherwise the preprocessor might treat =_kind-name= as an identifier, as many preprocessor predefined macro names begin with an underscore.

In a /char-literal-constant/, if the /kind-param/ preceding the underscore (=_=) is a /scalar-int-constant-name/, that constant name is subject to macro expansion. This needs to be explicit, as otherwise the preprocessor might treat =kind-name_= as an identifier.


**  Output form                   :noexport:
The user may request the preprocessor to produce the source representation after preprocessing. How this is requested is processor-dependent. If provided, the source form of the preprocessor output shall be bound by the following requirements.

*** =#line= and =#file= directives in the output
|--------------------------------+--------+--------------------------------|
| *ID*                             | *Status* | *Sources*                        |
|--------------------------------+--------+--------------------------------|
| [output-provenance-directives] | TBD    | [Flpp§]                        |
|                                |        | jor4                           |
|                                |        | [F2023§6.3.2 Free source form] |
|--------------------------------+--------+--------------------------------|

To show source code origin information (such as for error messages), the preprocessor may generate such origin information in the form of =#line= and =#file= directives. These directive lines may be up to 10,000 characters long, as in free-form Fortran input.


*** Directive lines begin with a =#= in column 1
|------------------------------+--------+---------------------------------|
| *ID*                           | *Status* | *Sources*                         |
|------------------------------+--------+---------------------------------|
| [output-directives-column-1] | TBD    | [Flpp§]                         |
|                              |        | jor4                            |
|                              |        | [F2023§6.3.3 Fixed source form] |
|------------------------------+--------+---------------------------------|


*** Fixed-form input becomes fixed-form output
|-------------------------+--------+---------------------------------|
| *ID*                      | *Status* | *Sources*                         |
|-------------------------+--------+---------------------------------|
| [output-fixed-to-fixed] | TBD    | [Flpp§]                         |
|                         |        | jor4                            |
|                         |        | [F2023§6.3.3 Fixed source form] |
|-------------------------+--------+---------------------------------|

When the preprocessor produces output corresponding to fixed-form Fortran input (such as with the =-E= option supported by some C compilers), it must produce valid Fortran fixed-form source code. This may require re-flowing the preprocessed output to the 72-column boundary.

- Column 1 :: Comments begin with a =C= or =c= in column 1.
- Columns 1-5 :: Optional statement label.
- Column 6 :: =0= or blank if not a continuation; continuation line otherwise.
- Columns 7-72 :: Fortran statement text


*** Free-form input becomes free-form output
|-----------------------+--------+--------------------------------|
| *ID*                    | *Status* | *Sources*                        |
|-----------------------+--------+--------------------------------|
| [output-free-to-free] | TBD    | [Flpp§]                        |
|                       |        | [F2023§6.3.2 Free source form] |
|-----------------------+--------+--------------------------------|

When the preprocessor produces output corresponding to free-form Fortran input (such as with the =-E= option supported by some C compilers), it must produce valid free-form Fortran source code. This may require re-flowing the preprocessed output to the 10,000-column boundary.

- Columns 1-10,000 :: Up to 10,000 characters of Fortran source text. If the source text is longer than 10,000 characters, up to 9,999 characters followed by =&= to continue additional source text on the next physical line, continuing up until one million characters of Fortran source.



* Syntax
The Bison grammar recognized in Phase 4. [[cite:&donnelly-2021-bison-manual]]

#+begin_src c
/*
 * A Bison grammar for Phase 4 of the Fortran preprocessor.
 *
 * This grammar assumes the tokenization of the input stream
 * performed in Phase 3. As such, we don't see whitespace
 * or comments. We do see identifiers, whole and real numbers,
 * and tokens that carry additional information.
 *
 * In general, the grammar rules follow Clause 6.10 of
 * the C programming language standard (ISO/IEC 9899:2018, IDT).
 *
 * The grammar rules for expressions represent the Fortran
 * standard's expression rules in clause 10.1.2.
 */

%token                  HASH_DEFINE "#define"
%token                  HASH_ELIF "#elif"
%token                  HASH_ELSE "#else"
%token                  HASH_ENDIF "#endif"
%token                  HASH_ERROR "#error"
%token                  HASH_IF "#if"
%token                  HASH_IFDEF "#ifdef"
%token                  HASH_IFNDEF "#ifndef"
%token                  HASH_INCLUDE "#include"
%token                  HASH_LINE "#line"
%token                  HASH_PRAGMA "#pragma"
%token                  HASH_UNDEF "#undef"
%token                  HASH_WARNING "#warning"

%token                  AMPERSAND "&"
%token                  AMPERSAND_AMPERSAND "&&"
%token                  AT "@"
%token                  BANG "!"
%token                  BANG_EQ "!="
%token                  BAR "|"
%token                  BAR_BAR "||"
%token                  CARET "^"
%token                  COLON ":"
%token                  COLON_COLON "::"
%token                  COMMA ","
%token                  DOLLAR "$"
%token                  ELLIPSES "..."
%token                  EO_ARGS
%token                  EOL
%token                  EQ "="
%token                  EQ_EQ "=="
%token                  FORMAT "format"
%token                  GT ">"
%token                  GT_EQ ">="
%token                  GT_GT ">>"
%token                  HASH "#"
%token                  HASH_HASH "##"
%token                  ID
%token                  ID_LPAREN                       /* only on #define */
%token                  IMPLICIT "implicit"
%token                  LBRACKET "["
%token                  LPAREN "("
%token                  LPAREN_SLASH "(/"
%token                  LT "<"
%token                  LT_EQ "<="
%token                  LT_LT "<<"
%token                  MINUS "-"
%token                  PERCENT "%"
%token                  PERIOD "."
%token                  PERIOD_AND_PERIOD ".and."
%token                  PERIOD_EQ_PERIOD ".eq."
%token                  PERIOD_EQV_PERIOD ".eqv."
%token                  PERIOD_FALSE_PERIOD ".false."
%token                  PERIOD_GE_PERIOD ".ge."
%token                  PERIOD_GT_PERIOD ".gt."
%token                  PERIOD_ID_PERIOD                /* user-defined operator */
%token                  PERIOD_LE_PERIOD ".le."
%token                  PERIOD_LT_PERIOD ".lt."
%token                  PERIOD_NE_PERIOD ".ne."
%token                  PERIOD_NEQV_PERIOD ".neqv."
%token                  PERIOD_NIL_PERIOD "nil."
%token                  PERIOD_NOT_PERIOD ".not."
%token                  PERIOD_OR_PERIOD ".or."
%token                  PERIOD_TRUE_PERIOD ".true."
%token                  PLUS "+"
%token                  POINTS "=>"
%token                  QUESTION "?"
%token                  RBRACKET "]"
%token                  REAL_NUMBER
%token                  RPAREN ")"
%token                  SEMICOLON ";"
%token                  SLASH "/"
%token                  SLASH_EQ "/="
%token                  SLASH_RPAREN "/)"
%token                  SLASH_SLASH "//"
%token                  STRING
%token                  TILDE "~"
%token                  TIMES "*"
%token                  TIMES_TIMES "**"
%token                  UNDERSCORE  "_"                 /* for _KIND, not ID */
%token                  WHOLE_NUMBER

%token                  UND_UND_FILE "__FILE__"
%token                  UND_UND_LINE "__LINE__"
%token                  UND_UND_DATE "__DATE__"
%token                  UND_UND_TIME "__TIME__"
%token                  UND_UND_STDFORTRAN "__STDFORTRAN__"
%token                  UND_UND_STDFORTRAN_VERSION "__STDFORTRAN_VERSION__"
%token                  UND_UND_VA_ARGS "VA_ARGS"
%token                  UND_UND_VA_OPT "VA_OPT"


%%


ExecutableProgram:
      CommandLineDefinitionList EO_ARGS PreprocessingFile
      ;

CommandLineDefinitionList:
      /* empty */
    | CommandLineDefinitionList CommandLineDefinition
      ;

CommandLineDefinition:
      IncludePath EOL
    | DefineArgument EOL
    | UndefineArgument EOL
      ;

IncludePath:
      HASH_INCLUDE STRING
      ;

DefineArgument:
      HASH_DEFINE ID ReplacementText
    | HASH_DEFINE ID_LPAREN LambdaList RPAREN ReplacementText
      ;

UndefineArgument:
      HASH_UNDEF ID
      ;

PreprocessingFile:
      /* empty */
    | GroupPartList
      ;

/* A GroupPart is some directive, or some Fortran text. */
GroupPartList:
      GroupPart
    | GroupPartList GroupPart
      ;

GroupPart:
      IfSection
    | ControlLine
    | NonDirective
    | FortranSourceLine
      ;

IfSection:
      HASH_IF Expression EOL HASH_ENDIF EOL
    | HASH_IF Expression EOL ElseGroup HASH_ENDIF EOL
    | HASH_IF Expression EOL ElifGroupList HASH_ENDIF EOL
    | HASH_IF Expression EOL ElifGroupList ElseGroup HASH_ENDIF EOL
    | HASH_IFDEF ID EOL GroupPartList HASH_ENDIF EOL
    | HASH_IFNDEF ID EOL GroupPartList HASH_ENDIF EOL
      ;

ElifGroupList:
      HASH_ELIF ID EOL GroupPartList
    | ElifGroupList HASH_ELIF ID EOL GroupPartList
      ;

ElseGroup:
      HASH_ELSE EOL GroupPartList
      ;

ControlLine:
      IncludeControlLine
    | DefineIdControlLine
    | DefineFunctionControlLine
    | LineControlLine
    | ErrorControlLine
    | WarningControlLine
    | PragmaControlLine
      ;

/* TODO Add PPTokens as alternative. */
IncludeControlLine:
      HASH_INCLUDE STRING EOL
      ;

DefineIdControlLine:
      HASH_DEFINE ID EOL
    | HASH_DEFINE ID PPTokenList EOL
      ;

/*
 * Parameter lists on macro functions are comma-separated
 * identifiers.
 */
DefineFunctionControlLine:
      HASH_DEFINE ID_LPAREN LambdaList RPAREN EOL
    | HASH_DEFINE ID_LPAREN LambdaList RPAREN ReplacementText EOL
      ;

LambdaList:
      /* empty */
    | ELLIPSES
    | IDList
    | IDList COMMA ELLIPSES
      ;

IDList:
      ID
    | IDList COMMA ID
      ;

LineControlLine:
      HASH_LINE STRING WHOLE_NUMBER EOL
    | HASH_LINE WHOLE_NUMBER EOL
      ;

ErrorControlLine:
      HASH_ERROR STRING EOL
      ;

WarningControlLine:
      HASH_WARNING STRING EOL
      ;

PragmaControlLine:
      HASH_PRAGMA PPTokenList EOL
      ;

NonDirective:
      HASH PPTokenList EOL
      ;

ReplacementText:
      ReplacementToken
    | ReplacementText ReplacementToken
      ;

/*
 * '#' and '##' operators can only appear in the replacement
 * text in #define directives.
 */
ReplacementToken:
      PPToken
    | HASH
    | HASH_HASH
      ;

PPTokenList:
      PPToken
    | PPTokenList PPToken
      ;

PPToken:
      FortranToken
    | CPPToken
      ;

PPTokenListExceptCommaRParen:
      PPTokenExceptCommaRParen
    | PPTokenListExceptCommaRParen PPTokenExceptCommaRParen
    ;

PPTokenExceptCommaRParen:
      FortranTokenExceptCommaRParen
    | CPPToken
      ;

/*
 * This should include every token that the tokenizer
 * could recognize. The tokenizer has to do some recognition
 * of Fortran operators (such as .AND.) and places where
 * preprocessing expansion should not * occur (such as FORMAT
 * and IMPLICIT).
 */

FortranTokenList:
      FortranToken
    | FortranTokenList FortranToken
    ;

FortranToken:
      FortranTokenAnywhere
    | COMMA
    | RPAREN
    | FORMAT
    | IMPLICIT
    ;

FortranTokenExceptCommaRParen:
      FortranTokenAnywhere
    | FORMAT
    | IMPLICIT
    ;

FortranTokenExceptFormatExplicit:
      FortranTokenAnywhere
    | COMMA
    | RPAREN
    ;

FortranTokenAnywhere:
      AT
    | COLON
    | COLON_COLON
    | DOLLAR
    | EQ
    | EQ_EQ
    | GT
    | GT_EQ
    | ID
    | LBRACKET
    | LPAREN
    | LT
    | LT_EQ
    | MINUS
    | PERCENT
    | PERIOD
    | PERIOD_AND_PERIOD
    | PERIOD_EQ_PERIOD
    | PERIOD_EQV_PERIOD
    | PERIOD_FALSE_PERIOD
    | PERIOD_GE_PERIOD
    | PERIOD_GT_PERIOD
    | PERIOD_ID_PERIOD                /* user-defined operator */
    | PERIOD_LE_PERIOD
    | PERIOD_LT_PERIOD
    | PERIOD_NE_PERIOD
    | PERIOD_NEQV_PERIOD
    | PERIOD_NIL_PERIOD
    | PERIOD_NOT_PERIOD
    | PERIOD_OR_PERIOD
    | PERIOD_TRUE_PERIOD
    | PLUS
    | POINTS
    | QUESTION
    | RBRACKET
    | REAL_NUMBER
    | SEMICOLON
    | SLASH
    | SLASH_EQ
    | SLASH_SLASH
    | STRING
    | TIMES
    | TIMES_TIMES
    | UNDERSCORE                      /* for _KIND, not within ID */
    | WHOLE_NUMBER
      ;

FortranTokenListExceptFormatExplicit:
      FortranTokenExceptFormatExplicit
    | FortranTokenListExceptFormatExplicit FortranTokenExceptFormatExplicit
      ;

/*
 * Tokens that can appear in C preprocessor replacement text
 * in addition to the Fortran tokens.
 */
CPPToken:
      AMPERSAND
    | AMPERSAND_AMPERSAND
    | BANG
    | BANG_EQ
    | BAR
    | BAR_BAR
    | CARET
    | GT_GT
    | LT_LT
    | TILDE
      ;

/* Following Fortran ISO/IEC 1539-1:2023 Clause 10.1.2
 *
 * modified for C-like syntax
 *
 *
 * INCITS and WG5 have agreed (so far) that the preprocessor
 * should conform to a subset of the C preprocessor
 * expression syntax. There has been no consensus
 * to include the standard Fortran operators, but
 * we include them here for completeness. (It is easier
 * to discuss removing them than adding them.)
 *
 * Note that operator precedence differs between C
 * and Fortran. The grammar below attempts to merge
 * these precedence lists, leaning towards C's
 * operator precedence.
 */
Expression:
      ConditionalExpr
    | Expression EquivOp ConditionalExpr
      ;

EquivOp:
      PERIOD_EQV_PERIOD
    | PERIOD_NEQV_PERIOD
      ;

ConditionalExpr:
      LogicalOrExpr QUESTION Expression COLON ConditionalExpr
    | LogicalOrExpr
      ;

LogicalOrExpr:
      LogicalAndExpr
    | LogicalOrExpr OrOp LogicalAndExpr
      ;

OrOp:
      BAR_BAR
    | PERIOD_OR_PERIOD
      ;

LogicalAndExpr:
      InclusiveOrExpr
    | LogicalAndExpr AndOp InclusiveOrExpr
      ;

AndOp:
      AMPERSAND_AMPERSAND
    | PERIOD_AND_PERIOD
      ;

InclusiveOrExpr:
      ExclusiveOrExpr
    | InclusiveOrExpr BAR ExclusiveOrExpr
      ;

ExclusiveOrExpr:
      AndExpr
    | ExclusiveOrExpr CARET AndExpr
      ;

AndExpr:
      EqualityExpr
    | AndExpr AMPERSAND EqualityExpr
      ;

EqualityExpr:
      RelationalExpr
    | EqualityExpr EqualityOp RelationalExpr
      ;

EqualityOp:
      PERIOD_EQ_PERIOD
    | PERIOD_NE_PERIOD
    | EQ_EQ
    | SLASH_EQ
    | BANG_EQ
      ;

RelationalExpr:
      ShiftExpr
    | RelationalExpr RelationalOp ShiftExpr
      ;

RelationalOp:
      PERIOD_LE_PERIOD
    | PERIOD_LT_PERIOD
    | PERIOD_GE_PERIOD
    | PERIOD_GT_PERIOD
    | LT
    | GT
    | LT_EQ
    | GT_EQ
      ;

ShiftExpr:
      CharacterExpr
    | ShiftExpr ShiftOp CharacterExpr
      ;

ShiftOp:
      LT_LT
    | GT_GT
      ;

CharacterExpr:
      AdditiveExpr
    | CharacterExpr SLASH_SLASH AdditiveExpr
      ;

AdditiveExpr:
      MultiplicativeExpr
    | AdditiveExpr AddOp MultiplicativeExpr
      ;

AddOp:
      PLUS
    | MINUS
      ;

MultiplicativeExpr:
      PowerExpr
    | MultiplicativeExpr MultOp PowerExpr
      ;

MultOp:
      TIMES
    | SLASH
    | PERCENT
      ;

PowerExpr:
      UnaryExpr
    | UnaryExpr TIMES_TIMES PowerExpr
      ;

UnaryExpr:
      UnaryOp PostfixExpr
    | PostfixExpr
      ;

UnaryOp:
      PLUS
    | MINUS
    | PERIOD_NOT_PERIOD
    | BANG
    | TILDE
      ;

PostfixExpr:
      PrimaryExpr
    | ID LPAREN RPAREN
    | ID LPAREN ActualArgumentList RPAREN
      ;

/* TODO: Really this should be properly nested parenthesized lists */
ActualArgumentList:
      PPTokenListExceptCommaRParen
    | ActualArgumentList COMMA PPTokenListExceptCommaRParen
      ;

/* Real numbers aren't allowed in conditional explessions */
PrimaryExpr:
      WHOLE_NUMBER
    | ID
    | PERIOD_FALSE_PERIOD
    | PERIOD_NIL_PERIOD
    | PERIOD_TRUE_PERIOD
    | LPAREN Expression RPAREN
    | PredefinedIdentifier
      ;

/* Identifiers known to the preprocessor (such as __FILE__) */
PredefinedIdentifier:
      UND_UND_FILE
    | UND_UND_LINE
    | UND_UND_DATE
    | UND_UND_TIME
    | UND_UND_STDFORTRAN
    | UND_UND_STDFORTRAN_VERSION
    | UND_UND_VA_ARGS
    | UND_UND_VA_OPT
    /* | ProcessorDefinedPPIdentifier */
      ;

/* /\* Implementation-defined predefined identifiers *\/ */
/* ProcessorDefinedPPIdentifier: */
/*       ; */

FortranSourceLine:
      EOL
    | FORMAT FortranTokenList EOL
    | IMPLICIT FortranTokenList EOL
    | FortranTokenListExceptFormatExplicit EOL
      ;
#+end_src


[[bibliographystyle:alpha]]
[[bibliography:references.bib]]
